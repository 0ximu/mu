#!/bin/bash
set -e

# MU Semantic Diff GitHub Action Entrypoint
# This script runs mu diff and posts results to PR comments

# =============================================================================
# Configuration
# =============================================================================

# Use environment variables set by action.yml
BASE_REF="${INPUT_BASE}"
HEAD_REF="${INPUT_HEAD}"
GITHUB_TOKEN="${INPUT_GITHUB_TOKEN}"
POST_COMMENT="${INPUT_COMMENT:-true}"
UPLOAD_ARTIFACT="${INPUT_ARTIFACT:-false}"
ARTIFACT_NAME="${INPUT_ARTIFACT_NAME:-mu-diff}"
MAX_COMMENT_SIZE="${INPUT_MAX_COMMENT_SIZE:-60000}"
WORKING_DIR="${INPUT_WORKING_DIRECTORY:-.}"
FAIL_ON_ERROR="${INPUT_FAIL_ON_ERROR:-false}"
UPDATE_COMMENT="${INPUT_UPDATE_COMMENT:-true}"

# GitHub context
GITHUB_REPOSITORY="${GITHUB_REPOSITORY}"
GITHUB_EVENT_NAME="${GITHUB_EVENT_NAME}"
GITHUB_EVENT_PATH="${GITHUB_EVENT_PATH}"
GITHUB_OUTPUT="${GITHUB_OUTPUT}"
GITHUB_STEP_SUMMARY="${GITHUB_STEP_SUMMARY}"

# Comment marker for identifying MU diff comments
COMMENT_MARKER="<!-- mu-semantic-diff -->"

# =============================================================================
# Helper Functions
# =============================================================================

log_info() {
    echo "::notice::$1"
}

log_warning() {
    echo "::warning::$1"
}

log_error() {
    echo "::error::$1"
}

log_debug() {
    echo "::debug::$1"
}

# Set output variable
set_output() {
    local name="$1"
    local value="$2"
    if [[ -n "$GITHUB_OUTPUT" ]]; then
        echo "${name}=${value}" >> "$GITHUB_OUTPUT"
    fi
}

# Set multiline output variable
set_output_multiline() {
    local name="$1"
    local value="$2"
    if [[ -n "$GITHUB_OUTPUT" ]]; then
        {
            echo "${name}<<EOF"
            echo "$value"
            echo "EOF"
        } >> "$GITHUB_OUTPUT"
    fi
}

# Get PR number from event
get_pr_number() {
    if [[ -f "$GITHUB_EVENT_PATH" ]]; then
        jq -r '.pull_request.number // .issue.number // empty' "$GITHUB_EVENT_PATH" 2>/dev/null || echo ""
    fi
}

# Get base SHA from PR event
get_base_sha() {
    if [[ -f "$GITHUB_EVENT_PATH" ]]; then
        jq -r '.pull_request.base.sha // empty' "$GITHUB_EVENT_PATH" 2>/dev/null || echo ""
    fi
}

# Get head SHA from PR event
get_head_sha() {
    if [[ -f "$GITHUB_EVENT_PATH" ]]; then
        jq -r '.pull_request.head.sha // empty' "$GITHUB_EVENT_PATH" 2>/dev/null || echo ""
    fi
}

# =============================================================================
# Git Setup
# =============================================================================

setup_git() {
    log_info "Setting up git..."

    cd "$GITHUB_WORKSPACE"

    # Ensure we have full git history for diff
    if git rev-parse --is-shallow-repository | grep -q "true"; then
        log_info "Repository is shallow, fetching full history..."
        git fetch --unshallow 2>/dev/null || git fetch --depth=1000 2>/dev/null || true
    fi

    # Fetch the base ref if it's not available locally
    if [[ -n "$BASE_REF" ]]; then
        log_info "Fetching base ref: $BASE_REF"
        git fetch origin "$BASE_REF" 2>/dev/null || true
    fi

    # Fetch the head ref if it's not available locally
    if [[ -n "$HEAD_REF" ]]; then
        log_info "Fetching head ref: $HEAD_REF"
        git fetch origin "$HEAD_REF" 2>/dev/null || true
    fi
}

# =============================================================================
# Run MU Diff
# =============================================================================

run_mu_diff() {
    local base="$1"
    local head="$2"
    local output_file="$3"

    log_info "Running mu diff: $base -> $head"

    cd "$GITHUB_WORKSPACE/$WORKING_DIR"

    # Run mu diff with markdown output
    if mu diff "$base" "$head" --format markdown --no-color -o "$output_file" 2>&1; then
        log_info "MU diff completed successfully"
        return 0
    else
        local exit_code=$?
        log_warning "MU diff exited with code $exit_code"

        # Exit code 2 means partial success (some files skipped)
        if [[ $exit_code -eq 2 ]]; then
            log_info "Partial success - some files were skipped"
            return 0
        fi

        return $exit_code
    fi
}

# =============================================================================
# Comment Formatting
# =============================================================================

format_comment() {
    local diff_content="$1"
    local base_sha="$2"
    local head_sha="$3"

    local base_short="${base_sha:0:7}"
    local head_short="${head_sha:0:7}"

    cat << EOF
${COMMENT_MARKER}
## MU Semantic Diff

**Base:** \`${base_short}\` **Head:** \`${head_short}\`

${diff_content}

---
<sub>Generated by MU Semantic Diff Action</sub>
EOF
}

truncate_content() {
    local content="$1"
    local max_size="$2"
    local content_length=${#content}

    if [[ $content_length -le $max_size ]]; then
        echo "$content"
        return 0
    fi

    # Calculate how much we need to truncate
    local truncation_notice=$'\n\n<details>\n<summary>Diff truncated (too large)</summary>\n\nThe full diff was too large to include in this comment. '
    truncation_notice+=$'Please check the workflow artifacts for the complete output.\n\n</details>'

    local notice_length=${#truncation_notice}
    local available_space=$((max_size - notice_length - 100))

    # Find a good break point (end of a line or section)
    local truncated="${content:0:$available_space}"

    # Try to find the last complete section (##)
    local last_section=$(echo "$truncated" | grep -n "^## " | tail -1 | cut -d: -f1)
    if [[ -n "$last_section" && $last_section -gt 10 ]]; then
        truncated=$(echo "$truncated" | head -n $((last_section - 1)))
    fi

    echo "${truncated}${truncation_notice}"
}

# =============================================================================
# GitHub API Functions
# =============================================================================

find_existing_comment() {
    local pr_number="$1"

    # Search for existing MU diff comment
    local comments_url="https://api.github.com/repos/${GITHUB_REPOSITORY}/issues/${pr_number}/comments"

    curl -s -H "Authorization: token ${GITHUB_TOKEN}" \
         -H "Accept: application/vnd.github.v3+json" \
         "$comments_url" | \
    jq -r ".[] | select(.body | contains(\"${COMMENT_MARKER}\")) | .id" | head -1
}

post_comment() {
    local pr_number="$1"
    local body="$2"

    local comments_url="https://api.github.com/repos/${GITHUB_REPOSITORY}/issues/${pr_number}/comments"

    # Escape the body for JSON
    local escaped_body
    escaped_body=$(echo "$body" | jq -Rs .)

    local response
    response=$(curl -s -X POST \
         -H "Authorization: token ${GITHUB_TOKEN}" \
         -H "Accept: application/vnd.github.v3+json" \
         "$comments_url" \
         -d "{\"body\": ${escaped_body}}")

    echo "$response" | jq -r '.html_url // empty'
}

update_comment() {
    local comment_id="$1"
    local body="$2"

    local comment_url="https://api.github.com/repos/${GITHUB_REPOSITORY}/issues/comments/${comment_id}"

    # Escape the body for JSON
    local escaped_body
    escaped_body=$(echo "$body" | jq -Rs .)

    local response
    response=$(curl -s -X PATCH \
         -H "Authorization: token ${GITHUB_TOKEN}" \
         -H "Accept: application/vnd.github.v3+json" \
         "$comment_url" \
         -d "{\"body\": ${escaped_body}}")

    echo "$response" | jq -r '.html_url // empty'
}

# =============================================================================
# Artifact Upload
# =============================================================================

prepare_artifact() {
    local diff_file="$1"
    local artifact_dir="$2"

    mkdir -p "$artifact_dir"
    cp "$diff_file" "$artifact_dir/mu-diff.md"

    # Also create a JSON version if available
    local json_file="${diff_file%.md}.json"
    if [[ -f "$json_file" ]]; then
        cp "$json_file" "$artifact_dir/mu-diff.json"
    fi
}

# =============================================================================
# Main
# =============================================================================

main() {
    log_info "Starting MU Semantic Diff Action"

    # Validate we're running in a PR context
    PR_NUMBER=$(get_pr_number)
    if [[ -z "$PR_NUMBER" && "$POST_COMMENT" == "true" ]]; then
        log_warning "Not running in a PR context, skipping comment posting"
        POST_COMMENT="false"
    fi

    # Determine base and head refs
    if [[ -z "$BASE_REF" ]]; then
        BASE_REF=$(get_base_sha)
        if [[ -z "$BASE_REF" ]]; then
            log_error "Could not determine base ref. Please provide 'base' input."
            exit 1
        fi
    fi

    if [[ -z "$HEAD_REF" ]]; then
        HEAD_REF=$(get_head_sha)
        if [[ -z "$HEAD_REF" ]]; then
            HEAD_REF="HEAD"
        fi
    fi

    log_info "Base ref: $BASE_REF"
    log_info "Head ref: $HEAD_REF"

    # Setup git
    setup_git

    # Create temp directory for outputs
    TEMP_DIR=$(mktemp -d)
    DIFF_OUTPUT="$TEMP_DIR/mu-diff.md"

    # Run MU diff
    DIFF_EXIT_CODE=0
    if ! run_mu_diff "$BASE_REF" "$HEAD_REF" "$DIFF_OUTPUT"; then
        DIFF_EXIT_CODE=$?
        log_warning "MU diff failed with exit code $DIFF_EXIT_CODE"

        if [[ "$FAIL_ON_ERROR" == "true" ]]; then
            log_error "Failing action due to mu diff error (fail-on-error is enabled)"
            exit $DIFF_EXIT_CODE
        fi

        # Create an error report instead
        cat << EOF > "$DIFF_OUTPUT"
## MU Semantic Diff

**Status:** Error

MU diff encountered an error while analyzing the changes.

**Exit Code:** $DIFF_EXIT_CODE

Please check the action logs for more details.
EOF
    fi

    # Read the diff output
    DIFF_CONTENT=""
    HAS_CHANGES="false"

    if [[ -f "$DIFF_OUTPUT" ]]; then
        DIFF_CONTENT=$(cat "$DIFF_OUTPUT")

        # Check if there are actual changes
        if ! echo "$DIFF_CONTENT" | grep -q "No semantic changes detected"; then
            HAS_CHANGES="true"
        fi
    fi

    # Set outputs
    set_output_multiline "diff-output" "$DIFF_CONTENT"
    set_output "has-changes" "$HAS_CHANGES"

    log_info "Has semantic changes: $HAS_CHANGES"

    # Post comment if enabled
    COMMENT_URL=""
    if [[ "$POST_COMMENT" == "true" && -n "$PR_NUMBER" ]]; then
        log_info "Posting comment to PR #$PR_NUMBER"

        # Format the comment
        COMMENT_BODY=$(format_comment "$DIFF_CONTENT" "$BASE_REF" "$HEAD_REF")

        # Truncate if necessary
        COMMENT_BODY=$(truncate_content "$COMMENT_BODY" "$MAX_COMMENT_SIZE")

        # Check for existing comment to update
        if [[ "$UPDATE_COMMENT" == "true" ]]; then
            EXISTING_COMMENT_ID=$(find_existing_comment "$PR_NUMBER")

            if [[ -n "$EXISTING_COMMENT_ID" ]]; then
                log_info "Updating existing comment $EXISTING_COMMENT_ID"
                COMMENT_URL=$(update_comment "$EXISTING_COMMENT_ID" "$COMMENT_BODY")
            else
                log_info "Creating new comment"
                COMMENT_URL=$(post_comment "$PR_NUMBER" "$COMMENT_BODY")
            fi
        else
            log_info "Creating new comment"
            COMMENT_URL=$(post_comment "$PR_NUMBER" "$COMMENT_BODY")
        fi

        if [[ -n "$COMMENT_URL" ]]; then
            log_info "Comment posted: $COMMENT_URL"
            set_output "comment-url" "$COMMENT_URL"
        else
            log_warning "Failed to post comment"
        fi
    fi

    # Prepare artifact if enabled
    if [[ "$UPLOAD_ARTIFACT" == "true" ]]; then
        ARTIFACT_DIR="$TEMP_DIR/artifact"
        prepare_artifact "$DIFF_OUTPUT" "$ARTIFACT_DIR"

        # The artifact upload is handled by the workflow using actions/upload-artifact
        # We just prepare the files and output the path
        log_info "Artifact prepared at: $ARTIFACT_DIR"

        # Copy to workspace for upload
        mkdir -p "$GITHUB_WORKSPACE/.mu-diff-artifact"
        cp -r "$ARTIFACT_DIR"/* "$GITHUB_WORKSPACE/.mu-diff-artifact/"
    fi

    # Write job summary
    if [[ -n "$GITHUB_STEP_SUMMARY" ]]; then
        cat << EOF >> "$GITHUB_STEP_SUMMARY"
## MU Semantic Diff

**Base:** \`${BASE_REF:0:7}\` **Head:** \`${HEAD_REF:0:7}\`
**Changes Detected:** $HAS_CHANGES

<details>
<summary>View Diff</summary>

$DIFF_CONTENT

</details>
EOF
    fi

    # Cleanup
    rm -rf "$TEMP_DIR"

    log_info "MU Semantic Diff Action completed successfully"
}

main "$@"
