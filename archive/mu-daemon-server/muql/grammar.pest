// MUQL Grammar - MU Query Language
// A SQL-like query language for exploring codebases

WHITESPACE = _{ " " | "\t" | "\n" | "\r" }
COMMENT = _{ "--" ~ (!"\n" ~ ANY)* }

// Entry point
query = { SOI ~ statement ~ EOI }

statement = {
    select_query
    | show_tables_query
    | show_columns_query
    | show_query
    | find_cycles_query
    | find_query
    | path_query
    | analyze_query
    | describe_query
    | terse_show_query
    | terse_select_query
}

// =============================================================================
// SELECT Query
// =============================================================================

select_query = {
    SELECT ~ select_list ~ FROM ~ node_type ~
    where_clause? ~
    group_by_clause? ~
    having_clause? ~
    order_clause? ~
    limit_clause?
}

select_list = { STAR | field_list }
field_list = { field ~ ("," ~ field)* }
field = { aggregate_fn ~ alias_clause? | identifier ~ alias_clause? }
aggregate_fn = {
    (COUNT | AVG | MAX | MIN | SUM) ~ "(" ~ (STAR | identifier) ~ ")"
}
alias_clause = { AS ~ identifier }

node_type = { FUNCTIONS | CLASSES | MODULES | NODES }

where_clause = { WHERE ~ condition }
condition = { or_condition }
or_condition = { and_condition ~ (OR ~ and_condition)* }
and_condition = { comparison ~ (AND ~ comparison)* }

comparison = {
    aggregate_fn ~ comparison_op ~ value
    | identifier ~ comparison_op ~ value
    | identifier ~ LIKE ~ string_value
    | identifier ~ IN ~ "(" ~ value_list ~ ")"
    | identifier ~ NOT ~ IN ~ "(" ~ value_list ~ ")"
    | "(" ~ condition ~ ")"
}

comparison_op = { ">=" | "<=" | "!=" | "<>" | "=" | ">" | "<" }
value = { string_value | number_value | TRUE | FALSE | NULL }
value_list = { value ~ ("," ~ value)* }
string_value = @{ "'" ~ (!"'" ~ ANY)* ~ "'" | "\"" ~ (!"\"" ~ ANY)* ~ "\"" }
number_value = @{ "-"? ~ ASCII_DIGIT+ }

group_by_clause = { GROUP ~ BY ~ group_field ~ ("," ~ group_field)* }
group_field = { identifier }

having_clause = { HAVING ~ condition }

order_clause = { ORDER ~ BY ~ order_field ~ ("," ~ order_field)* }
order_field = { identifier ~ (ASC | DESC)? }
limit_clause = { LIMIT ~ number_value }

// =============================================================================
// SHOW Query (Graph Traversal)
// =============================================================================

show_query = { SHOW ~ show_type ~ OF ~ node_ref ~ depth_clause? }

show_type = {
    DEPENDENCIES | DEPENDENTS | CALLERS | CALLEES |
    INHERITANCE | IMPLEMENTATIONS | CHILDREN | PARENTS |
    IMPACT | ANCESTORS
}

node_ref = { string_value | qualified_name | identifier }
qualified_name = @{ identifier ~ ("." ~ identifier)+ }
depth_clause = { DEPTH ~ number_value }

// =============================================================================
// FIND Query
// =============================================================================

find_cycles_query = { FIND ~ CYCLES ~ edge_type_filter? }
edge_type_filter = {
    WHERE ~ EDGE_TYPE ~ comparison_op ~ string_value
    | WHERE ~ EDGE_TYPE ~ IN ~ "(" ~ string_list ~ ")"
}
string_list = { string_value ~ ("," ~ string_value)* }

find_query = { FIND ~ find_node_type ~ find_condition }
find_node_type = { FUNCTIONS | CLASSES | MODULES | METHODS }

find_condition = {
    CALLING ~ node_ref
    | CALLED ~ BY ~ node_ref
    | IMPORTING ~ node_ref
    | IMPORTED ~ BY ~ node_ref
    | INHERITING ~ node_ref
    | IMPLEMENTING ~ node_ref
    | WITH ~ DECORATOR ~ string_value
    | WITH ~ ANNOTATION ~ string_value
    | MATCHING ~ string_value
    | SIMILAR ~ TO ~ node_ref
}

// =============================================================================
// PATH Query
// =============================================================================

path_query = {
    PATH ~ FROM ~ node_ref ~ TO ~ node_ref ~
    max_depth_clause? ~ via_clause?
}

max_depth_clause = { MAX ~ DEPTH ~ number_value }
via_clause = { VIA ~ edge_type }
edge_type = { CALLS | IMPORTS | INHERITS | USES | CONTAINS }

// =============================================================================
// ANALYZE Query
// =============================================================================

analyze_query = { ANALYZE ~ analysis_type ~ for_clause? }
analysis_type = {
    COUPLING | COHESION | COMPLEXITY | HOTSPOTS |
    CIRCULAR | UNUSED | IMPACT_KW
}
for_clause = { FOR ~ node_ref }

// =============================================================================
// DESCRIBE Query (and SHOW TABLES/COLUMNS aliases)
// =============================================================================

describe_query = { DESCRIBE ~ describe_target }
describe_target = {
    TABLES
    | COLUMNS ~ FROM ~ node_type
    | node_type
}

// SHOW TABLES / SHOW COLUMNS - aliases for DESCRIBE
show_tables_query = { SHOW ~ TABLES }
show_columns_query = { SHOW ~ COLUMNS ~ FROM ~ node_type }

// =============================================================================
// Identifiers and Keywords
// =============================================================================

identifier = @{ (ASCII_ALPHA | "_") ~ (ASCII_ALPHANUMERIC | "_")* }

// SQL Keywords (case insensitive)
SELECT = _{ ^"select" }
FROM = _{ ^"from" }
WHERE = _{ ^"where" }
AND = _{ ^"and" }
OR = _{ ^"or" }
NOT = _{ ^"not" }
IN = _{ ^"in" }
LIKE = { ^"like" }
ORDER = _{ ^"order" }
BY = _{ ^"by" }
ASC = { ^"asc" }
DESC = { ^"desc" }
LIMIT = _{ ^"limit" }
GROUP = _{ ^"group" }
HAVING = _{ ^"having" }
AS = _{ ^"as" }
TRUE = { ^"true" }
FALSE = { ^"false" }
NULL = { ^"null" }
STAR = { "*" }

// Aggregate functions
COUNT = { ^"count" }
AVG = { ^"avg" }
MAX = { ^"max" }
MIN = { ^"min" }
SUM = { ^"sum" }

// Node types
FUNCTIONS = { ^"functions" }
CLASSES = { ^"classes" }
MODULES = { ^"modules" }
NODES = { ^"nodes" }
METHODS = { ^"methods" }

// SHOW keywords
SHOW = _{ ^"show" }
OF = _{ ^"of" }
DEPTH = _{ ^"depth" }
DEPENDENCIES = { ^"dependencies" }
DEPENDENTS = { ^"dependents" }
CALLERS = { ^"callers" }
CALLEES = { ^"callees" }
INHERITANCE = { ^"inheritance" }
IMPLEMENTATIONS = { ^"implementations" }
CHILDREN = { ^"children" }
PARENTS = { ^"parents" }
IMPACT = { ^"impact" }
ANCESTORS = { ^"ancestors" }

// FIND keywords
FIND = _{ ^"find" }
CYCLES = { ^"cycles" }
EDGE_TYPE = { ^"edge_type" }
CALLING = { ^"calling" }
CALLED = { ^"called" }
IMPORTING = { ^"importing" }
IMPORTED = { ^"imported" }
INHERITING = { ^"inheriting" }
IMPLEMENTING = { ^"implementing" }
WITH = _{ ^"with" }
DECORATOR = { ^"decorator" }
ANNOTATION = { ^"annotation" }
MATCHING = { ^"matching" }
SIMILAR = { ^"similar" }
TO = _{ ^"to" }

// PATH keywords
PATH = _{ ^"path" }
VIA = _{ ^"via" }
CALLS = { ^"calls" }
IMPORTS = { ^"imports" }
INHERITS = { ^"inherits" }
USES = { ^"uses" }
CONTAINS = { ^"contains" }

// ANALYZE keywords
ANALYZE = _{ ^"analyze" }
FOR = _{ ^"for" }
COUPLING = { ^"coupling" }
COHESION = { ^"cohesion" }
COMPLEXITY = { ^"complexity" }
HOTSPOTS = { ^"hotspots" }
CIRCULAR = { ^"circular" }
UNUSED = { ^"unused" }
IMPACT_KW = { ^"impact" }

// DESCRIBE keywords
DESCRIBE = _{ ^"describe" }
TABLES = { ^"tables" }
COLUMNS = { ^"columns" }

// =============================================================================
// Terse Syntax (LLM-optimized)
// =============================================================================

// Terse SHOW queries: deps, rdeps, callers, callees, impact
terse_show_query = {
    terse_deps_query
    | terse_rdeps_query
    | terse_callers_query
    | terse_callees_query
    | terse_impact_query
}

terse_deps_query = { DEPS ~ node_ref ~ terse_depth_clause? }
terse_rdeps_query = { RDEPS ~ node_ref ~ terse_depth_clause? }
terse_callers_query = { CALLERS ~ node_ref ~ terse_depth_clause? }
terse_callees_query = { CALLEES ~ node_ref ~ terse_depth_clause? }
terse_impact_query = { IMPACT ~ node_ref }

// Terse depth: d2, d3, etc.
terse_depth_clause = { TERSE_DEPTH ~ number_value }
TERSE_DEPTH = _{ ^"d" }

// Terse SHOW keywords
DEPS = _{ ^"deps" }
RDEPS = _{ ^"rdeps" }

// Terse SELECT queries: fn c>50 sort c- 10
terse_select_query = {
    terse_node_type ~ terse_where_clause? ~ terse_order_clause? ~ terse_limit_clause?
}

terse_node_type = { FN | CLS | MOD | METH }
FN = { ^"fn" }
CLS = { ^"cls" }
MOD = { ^"mod" }
METH = { ^"meth" }

// Terse WHERE clause (implicit): c>50 instead of WHERE complexity > 50
terse_where_clause = { terse_condition }
terse_condition = { terse_and_condition ~ (OR ~ terse_and_condition)* }
terse_and_condition = { terse_comparison ~ (AND ~ terse_comparison)* }
terse_comparison = { terse_field ~ terse_comparison_op ~ value }

// Terse field aliases
terse_field = { COMPLEXITY_TERSE | NAME_TERSE | FILEPATH_TERSE | QUALNAME_TERSE | identifier }
COMPLEXITY_TERSE = { ^"c" }
NAME_TERSE = { ^"n" }
FILEPATH_TERSE = { ^"fp" }
QUALNAME_TERSE = { ^"qn" }

// Terse comparison operators (same as regular + TILDE for LIKE)
terse_comparison_op = { ">=" | "<=" | "!=" | "<>" | "=" | ">" | "<" | TILDE }
TILDE = { "~" }

// Terse ORDER BY: sort c- or sort c desc
terse_order_clause = { SORT ~ terse_order_field ~ ("," ~ terse_order_field)* }
SORT = _{ ^"sort" }

terse_order_field = { terse_field ~ terse_order_direction? }
terse_order_direction = { MINUS | PLUS | ASC | DESC }
MINUS = { "-" }
PLUS = { "+" }

// Terse LIMIT: bare number at end, or lim N, or limit N
terse_limit_clause = { (LIMIT | LIM) ~ number_value | number_value }
LIM = _{ ^"lim" }
