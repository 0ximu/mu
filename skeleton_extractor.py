import os
import sys
import re
from pathlib import Path

# CONFIGURATION (Synced with Triage V4)
IGNORE_DIRS = {
    '.git', 'node_modules', 'venv', '.venv', 'env', '.env', 'dist', 'build',
    '__pycache__', '.next', 'target', 'vendor', '.idea', '.vscode',
    'examples', 'example', 'fixtures', 'test-fixtures', '__tests__', 'e2e', 'tests',
    'test', 'spec', 'specs', # Added specific test dirs
    'Pods', 'DerivedData', '.build', 'ios', 'android', 'cmake-build-debug',
    'typings', 'coverage', 'site-packages', 'migrations', 'alembic', # Ignore DB migrations too
    'obj', 'bin', 'Debug', 'Release', 'Migrations' # C# build artifacts & EF migrations
}

IGNORE_EXTS = {
    '.png', '.jpg', '.jpeg', '.svg', '.gif', '.ico',
    '.json', '.lock', '.map', '.txt', '.md', '.xml',
    '.csv', '.log', '.sql', '.sqlite', '.css', '.scss'
}

def extract_skeleton(file_path):
    ext = Path(file_path).suffix.lower()
    lang_map = {
        ".py": "python",
        ".ts": "typescript", ".tsx": "typescript", ".js": "typescript", ".jsx": "typescript",
        ".cs": "csharp"
    }
    lang = lang_map.get(ext)

    if not lang:
        return None

    skeleton = []
    try:
        with open(file_path, 'r', errors='ignore') as f:
            lines = f.readlines()
    except:
        return None

    for line in lines:
        stripped = line.strip()

        # 1. Keep Imports/Usings (Crucial for Dependency Graph)
        if stripped.startswith(("import ", "from ", "require(", "include ", "using ")):
            skeleton.append(line.rstrip())
            continue

        # 2. Extract Signatures (Strip Bodies)
        if lang == "python":
            # Keep decorators, classes, functions, and async
            if stripped.startswith(("@", "class ", "def ", "async def ")):
                if stripped.endswith(":"):
                    skeleton.append(line.rstrip() + " ...")
                else:
                    skeleton.append(line.rstrip())

        elif lang == "typescript":
            # Keep exports, interfaces, types, classes
            if stripped.startswith(("export ", "import ", "interface ", "type ", "class ", "async ")):
                if "{" in stripped and "}" not in stripped:
                     # Opening brace, strip body
                     skeleton.append(stripped.split("{")[0].strip() + " { ... }")
                elif "{" not in stripped and ";" not in stripped:
                     # Likely a decorator or partial line
                     skeleton.append(stripped)
                else:
                     skeleton.append(stripped)

        elif lang == "csharp":
            # Keep namespaces, classes, interfaces, methods, properties
            if stripped.startswith(("namespace ", "[")) or \
               any(kw in stripped for kw in ["class ", "interface ", "enum ", "struct ", "record "]):
                skeleton.append(line.rstrip())
            # Public/private/protected methods and properties
            elif any(stripped.startswith(mod) for mod in ["public ", "private ", "protected ", "internal ", "async "]):
                if "{" in stripped:
                    skeleton.append(stripped.split("{")[0].strip() + " { ... }")
                else:
                    skeleton.append(line.rstrip())

    return "\n".join(skeleton)

def process_module(module_path):
    module_path = Path(module_path).resolve()
    print(f"ðŸ’€ Soapy Mushroom Skeleton V2: {module_path}")

    full_skeleton = f"# DOCUMENTATION SKELETON FOR: {module_path.name}\n"
    full_skeleton += f"# GENERATED BY GLASS BOX TRIAGE\n\n"

    file_count = 0

    for root, dirs, files in os.walk(module_path):
        # Prune directories
        dirs[:] = [d for d in dirs if d not in IGNORE_DIRS]

        for file in files:
            ext = Path(file).suffix.lower()
            if ext in IGNORE_EXTS:
                continue

            path = Path(root) / file
            skel = extract_skeleton(path)

            if skel:
                rel_path = path.relative_to(module_path)
                full_skeleton += f"\n# {'='*30}\n"
                full_skeleton += f"# FILE: {rel_path}\n"
                full_skeleton += f"# {'='*30}\n"
                full_skeleton += skel + "\n"
                file_count += 1

    return full_skeleton, file_count

if __name__ == "__main__":
    if len(sys.argv) < 2:
        print("Usage: python skeleton_extractor_v2.py <path_to_module>")
        sys.exit(1)

    result, count = process_module(sys.argv[1])

    # Token Estimation (Roughly 4 chars per token)
    est_tokens = len(result) / 4

    out_file = "skeleton_output.txt"
    with open(out_file, "w") as f:
        f.write(result)

    print(f"âœ… Skeleton saved to {out_file}")
    print(f"ðŸ“„ Files Scanned: {count}")
    print(f"ðŸ“ Size: {len(result)/1024:.2f} KB")
    print(f"ðŸª™ Est. Tokens: {est_tokens:,.0f}")

    if est_tokens > 100000:
        print("âš ï¸  WARNING: Payload is large (>100k tokens). Consider splitting this module.")
    else:
        print("ðŸŸ¢  STATUS: Ready for Wave 2 (Claude/Gemini).")
